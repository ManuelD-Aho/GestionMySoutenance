
/***********************************************************************************
 * Fichier: src/Config\Container.php
 ***********************************************************************************/

<?php
// src/Config/Container.php

namespace App\Config;

use PDO;
use Exception;
use App\Backend\Util\FormValidator;
use App\Backend\Util\DatabaseSessionHandler;

// --- Importation des Modèles Spécifiques ---
use App\Backend\Model\BaseModel;
use App\Backend\Model\GenericModel;
use App\Backend\Model\Utilisateur;
use App\Backend\Model\HistoriqueMotDePasse;
use App\Backend\Model\Sessions;
use App\Backend\Model\RapportEtudiant;
use App\Backend\Model\Reclamation;
use App\Backend\Model\Delegation;

// --- Importation des Services et de leurs Interfaces ---
use App\Backend\Service\Securite\{ServiceSecurite, ServiceSecuriteInterface};
use App\Backend\Service\Utilisateur\{ServiceUtilisateur, ServiceUtilisateurInterface};
use App\Backend\Service\ParcoursAcademique\{ServiceParcoursAcademique, ServiceParcoursAcademiqueInterface};
use App\Backend\Service\WorkflowSoutenance\{ServiceWorkflowSoutenance, ServiceWorkflowSoutenanceInterface};
use App\Backend\Service\Systeme\{ServiceSysteme, ServiceSystemeInterface};
use App\Backend\Service\Communication\{ServiceCommunication, ServiceCommunicationInterface};
use App\Backend\Service\Document\{ServiceDocument, ServiceDocumentInterface};
use App\Backend\Service\Supervision\{ServiceSupervision, ServiceSupervisionInterface};

// --- Importation de tous les Contrôleurs ---
use App\Backend\Controller\Administration\{AdminDashboardController, ConfigurationController, SupervisionController, UtilisateurController};
use App\Backend\Controller\Commission\{CommissionDashboardController, WorkflowCommissionController};
use App\Backend\Controller\Etudiant\{EtudiantDashboardController, ProfilEtudiantController, RapportController};
use App\Backend\Controller\PersonnelAdministratif\{PersonnelDashboardController, ScolariteController};
use App\Backend\Controller\{AssetController, AuthentificationController, BaseController, DashboardController, HomeController};

class Container
{
    private array $definitions = [];
    private array $instances = [];

    private array $tableSchema = [
        'acquerir' => ['id_grade', 'numero_enseignant'],
        'action' => 'id_action',
        'affecter' => ['numero_enseignant', 'id_rapport_etudiant', 'id_statut_jury'],
        'annee_academique' => 'id_annee_academique',
        'approuver' => ['numero_personnel_administratif', 'id_rapport_etudiant'],
        'attribuer' => ['numero_enseignant', 'id_specialite'],
        'compte_rendu' => 'id_compte_rendu',
        'conformite_rapport_details' => 'id_conformite_detail',
        'conversation' => 'id_conversation',
        'critere_conformite_ref' => 'id_critere',
        'decision_passage_ref' => 'id_decision_passage',
        'decision_validation_pv_ref' => 'id_decision_validation_pv',
        'decision_vote_ref' => 'id_decision_vote',
        'document_genere' => 'id_document_genere',
        'ecue' => 'id_ecue',
        'enregistrer' => 'id_enregistrement',
        'enseignant' => 'numero_enseignant',
        'entreprise' => 'id_entreprise',
        'etudiant' => 'numero_carte_etudiant',
        'evaluer' => ['numero_carte_etudiant', 'id_ecue', 'id_annee_academique'],
        'faire_stage' => ['id_entreprise', 'numero_carte_etudiant'],
        'fonction' => 'id_fonction',
        'grade' => 'id_grade',
        'groupe_utilisateur' => 'id_groupe_utilisateur',
        'inscrire' => ['numero_carte_etudiant', 'id_niveau_etude', 'id_annee_academique'],
        'lecture_message' => ['id_message_chat', 'numero_utilisateur'],
        'matrice_notification_regles' => 'id_regle',
        'message_chat' => 'id_message_chat',
        'niveau_acces_donne' => 'id_niveau_acces_donne',
        'niveau_etude' => 'id_niveau_etude',
        'notification' => 'id_notification',
        'occuper' => ['id_fonction', 'numero_enseignant'],
        'parametres_systeme' => 'cle',
        'participant_conversation' => ['id_conversation', 'numero_utilisateur'],
        'penalite' => 'id_penalite',
        'personnel_administratif' => 'numero_personnel_administratif',
        'pister' => 'id_piste',
        'pv_session_rapport' => ['id_compte_rendu', 'id_rapport_etudiant'],
        'queue_jobs' => 'id',
        'rapport_modele' => 'id_modele',
        'rapport_modele_assignation' => ['id_modele', 'id_niveau_etude'],
        'rapport_modele_section' => 'id_section_modele',
        'rattacher' => ['id_groupe_utilisateur', 'id_traitement'],
        'recevoir' => 'id_reception',
        'rendre' => ['numero_enseignant', 'id_compte_rendu'],
        'section_rapport' => ['id_rapport_etudiant', 'titre_section'],
        'sequences' => ['nom_sequence', 'annee'],
        'session_rapport' => ['id_session', 'id_rapport_etudiant'],
        'session_validation' => 'id_session',
        'specialite' => 'id_specialite',
        'statut_conformite_ref' => 'id_statut_conformite',
        'statut_jury' => 'id_statut_jury',
        'statut_paiement_ref' => 'id_statut_paiement',
        'statut_penalite_ref' => 'id_statut_penalite',
        'statut_pv_ref' => 'id_statut_pv',
        'statut_rapport_ref' => 'id_statut_rapport',
        'statut_reclamation_ref' => 'id_statut_reclamation',
        'traitement' => 'id_traitement',
        'type_document_ref' => 'id_type_document',
        'type_utilisateur' => 'id_type_utilisateur',
        'ue' => 'id_ue',
        'validation_pv' => ['id_compte_rendu', 'numero_enseignant'],
        'vote_commission' => 'id_vote',
        'delegation' => 'id_delegation',
        'historique_mot_de_passe' => 'id_historique_mdp',
        'sessions' => 'session_id',
        'utilisateur' => 'numero_utilisateur',
    ];

    public function __construct()
    {
        $this->definitions['PDO'] = fn () => Database::getInstance()->getConnection();
        $this->definitions[FormValidator::class] = fn () => new FormValidator();
        $this->definitions[DatabaseSessionHandler::class] = fn () => new DatabaseSessionHandler();

        $this->registerModels();
        $this->registerServices();
        $this->registerControllers();
    }

    private function registerModels(): void
    {
        $specificModels = [
            Utilisateur::class, HistoriqueMotDePasse::class, Sessions::class,
            RapportEtudiant::class, Reclamation::class, Delegation::class
        ];
        foreach ($specificModels as $modelClass) {
            $this->definitions[$modelClass] = fn ($c) => new $modelClass($c->get('PDO'));
        }
    }

    private function registerServices(): void
    {
        // ServiceSupervision (dépend de modèles)
        $this->definitions[ServiceSupervision::class] = fn ($c) => new ServiceSupervision(
            $c->get('PDO'),
            $c->getModelForTable('enregistrer'),
            $c->getModelForTable('pister'),
            $c->getModelForTable('action'),
            $c->get(Utilisateur::class),
            $c->get(RapportEtudiant::class)
        );
        $this->alias(ServiceSupervisionInterface::class, ServiceSupervision::class);

        // ServiceSysteme (dépend de Supervision)
        $this->definitions[ServiceSysteme::class] = fn ($c) => new ServiceSysteme(
            $c->get('PDO'),
            $c->getModelForTable('parametres_systeme'),
            $c->getModelForTable('annee_academique'),
            $c->getModelForTable('sequences'),
            $c->get(ServiceSupervisionInterface::class),
            $c
        );
        $this->alias(ServiceSystemeInterface::class, ServiceSysteme::class);

        // ServiceCommunication (dépend de Systeme & Supervision)
        $this->definitions[ServiceCommunication::class] = fn ($c) => new ServiceCommunication(
            $c->get('PDO'),
            $c->getModelForTable('notification'),
            $c->getModelForTable('recevoir'),
            $c->getModelForTable('conversation'),
            $c->getModelForTable('message_chat'),
            $c->getModelForTable('participant_conversation'),
            $c->getModelForTable('matrice_notification_regles'),
            $c->getModelForTable('utilisateur'),
            $c->get(ServiceSystemeInterface::class),
            $c->get(ServiceSupervisionInterface::class)
        );
        $this->alias(ServiceCommunicationInterface::class, ServiceCommunication::class);

        // ServiceSecurite (dépend de Supervision)
        $this->definitions[ServiceSecurite::class] = fn ($c) => new ServiceSecurite(
            $c->get('PDO'),
            $c->get(Utilisateur::class),
            $c->get(HistoriqueMotDePasse::class),
            $c->get(Sessions::class),
            $c->getModelForTable('rattacher'),
            $c->get(ServiceSupervisionInterface::class),
            // ** CORRECTION APPLIQUÉE ICI ** : Ajout de la dépendance manquante
            $c->get(Delegation::class)
        );
        $this->alias(ServiceSecuriteInterface::class, ServiceSecurite::class);

        // ServiceUtilisateur (dépend de Systeme, Supervision, Communication)
        $this->definitions[ServiceUtilisateur::class] = function ($c) {
            $service = new ServiceUtilisateur(
                $c->get('PDO'),
                $c->get(Utilisateur::class),
                $c->getModelForTable('etudiant'),
                $c->getModelForTable('enseignant'),
                $c->getModelForTable('personnel_administratif'),
                $c->get(Delegation::class),
                $c->get(ServiceSystemeInterface::class),
                $c->get(ServiceSupervisionInterface::class)
            );
            $service->setCommunicationService($c->get(ServiceCommunicationInterface::class));
            return $service;
        };
        $this->alias(ServiceUtilisateurInterface::class, ServiceUtilisateur::class);

        // ServiceDocument (dépend de Systeme, Supervision)
        $this->definitions[ServiceDocument::class] = fn ($c) => new ServiceDocument(
            $c->get('PDO'),
            $c->getModelForTable('document_genere'),
            $c->getModelForTable('etudiant'),
            $c->getModelForTable('inscrire'),
            $c->getModelForTable('evaluer'),
            $c->getModelForTable('compte_rendu'),
            $c->getModelForTable('annee_academique'),
            $c->get(RapportEtudiant::class),
            $c->getModelForTable('section_rapport'),
            $c->get(ServiceSystemeInterface::class),
            $c->get(ServiceSupervisionInterface::class)
        );
        $this->alias(ServiceDocumentInterface::class, ServiceDocument::class);

        // ServiceParcoursAcademique (dépend de Systeme, Supervision)
        $this->definitions[ServiceParcoursAcademique::class] = fn ($c) => new ServiceParcoursAcademique(
            $c->get('PDO'),
            $c->getModelForTable('inscrire'),
            $c->getModelForTable('evaluer'),
            $c->getModelForTable('faire_stage'),
            $c->getModelForTable('penalite'),
            $c->get(ServiceSystemeInterface::class),
            $c->get(ServiceSupervisionInterface::class)
        );
        $this->alias(ServiceParcoursAcademiqueInterface::class, ServiceParcoursAcademique::class);

        // ServiceWorkflowSoutenance (dépend de plusieurs autres services)
        $this->definitions[ServiceWorkflowSoutenance::class] = fn ($c) => new ServiceWorkflowSoutenance(
            $c->get('PDO'),
            $c->get(RapportEtudiant::class),
            $c->get(Reclamation::class),
            $c->getModelForTable('section_rapport'),
            $c->getModelForTable('approuver'),
            $c->getModelForTable('conformite_rapport_details'),
            $c->getModelForTable('affecter'),
            $c->getModelForTable('vote_commission'),
            $c->getModelForTable('compte_rendu'),
            $c->getModelForTable('validation_pv'),
            $c->getModelForTable('session_validation'),
            $c->getModelForTable('session_rapport'),
            $c->get(ServiceCommunicationInterface::class),
            $c->get(ServiceDocumentInterface::class),
            $c->get(ServiceSupervisionInterface::class),
            $c->get(ServiceSystemeInterface::class)
        );
        $this->alias(ServiceWorkflowSoutenanceInterface::class, ServiceWorkflowSoutenance::class);
    }

    private function registerControllers(): void
    {
        $controllers = [
            AdminDashboardController::class, ConfigurationController::class, SupervisionController::class, UtilisateurController::class,
            CommissionDashboardController::class, WorkflowCommissionController::class,
            EtudiantDashboardController::class, ProfilEtudiantController::class, RapportController::class,
            PersonnelDashboardController::class, ScolariteController::class,
            AssetController::class, AuthentificationController::class, DashboardController::class, HomeController::class
        ];

        foreach ($controllers as $controller) {
            $this->definitions[$controller] = function ($c) use ($controller) {
                $reflection = new \ReflectionClass($controller);
                $constructor = $reflection->getConstructor();
                if (!$constructor) return new $controller();

                $dependencies = [];
                foreach ($constructor->getParameters() as $param) {
                    $type = $param->getType();
                    if ($type instanceof \ReflectionNamedType && !$type->isBuiltin()) {
                        $dependencies[] = $c->get($type->getName());
                    } else {
                        throw new Exception("Paramètre non injectable '{$param->getName()}' dans le constructeur de " . $controller);
                    }
                }
                return new $controller(...$dependencies);
            };
        }
    }

    public function get(string $id)
    {
        if (!isset($this->instances[$id])) {
            if (!isset($this->definitions[$id])) {
                throw new Exception("Service ou classe '{$id}' non défini dans le conteneur.");
            }
            $this->instances[$id] = $this->definitions[$id]($this);
        }
        return $this->instances[$id];
    }

    public function getModelForTable(string $tableName): GenericModel
    {
        $instanceKey = 'model.' . $tableName;
        if (!isset($this->instances[$instanceKey])) {
            if (!isset($this->tableSchema[$tableName])) {
                throw new Exception("Schéma non défini pour la table '{$tableName}' dans le Container.");
            }
            $primaryKey = $this->tableSchema[$tableName];
            $this->instances[$instanceKey] = new GenericModel($this->get('PDO'), $tableName, $primaryKey);
        }
        return $this->instances[$instanceKey];
    }

    private function alias(string $alias, string $concrete): void
    {
        $this->definitions[$alias] = fn ($c) => $c->get($concrete);
    }
}

/***********************************************************************************
 * Fichier: src/Config\Database.php
 ***********************************************************************************/

<?php

namespace App\Config;

use PDO;
use PDOException;

class Database {
    private static ?self $instance = null;
    private ?PDO $pdoInstance = null;

    private function __construct() {
        $host = getenv('DB_HOST') ?: 'localhost';
        $port = getenv('DB_PORT') ?: '3306';
        $db   = getenv('DB_DATABASE') ?: 'mysoutenance';
        $user = getenv('DB_USER') ?: 'root';
        $pass = getenv('DB_PASSWORD') ?: '';
        $charset = 'utf8mb4';

        $dsn = "mysql:host={$host};port={$port};dbname={$db};charset={$charset}";
        $options = [
            PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES   => false,
        ];

        try {
            $this->pdoInstance = new PDO($dsn, $user, $pass, $options);
        } catch (PDOException $e) {
            error_log("PDO Connection Error: " . $e->getMessage());
            throw new PDOException('Connexion à la base de données impossible. Veuillez vérifier la configuration ou contacter l\'administrateur.', (int)$e->getCode(), $e);
        }
    }

    public static function getInstance(): self {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public function getConnection(): PDO {
        if ($this->pdoInstance === null) {
            throw new PDOException("La connexion PDO n'a pas été initialisée. Assurez-vous que getInstance() est appelé.");
        }
        return $this->pdoInstance;
    }

    private function __clone(){}

    public function __wakeup(){
        throw new \Exception("La désérialisation du singleton Database n'est pas autorisée.");
    }
}
