
/***********************************************************************************
 * Fichier: Public\.htaccess
 ***********************************************************************************/

# GestionMySoutenance .htaccess

# Emp√™cher le listage des r√©pertoires
Options -Indexes

# Cacher la signature du serveur
ServerSignature Off

<IfModule mod_rewrite.c>
    RewriteEngine On

    # Ne pas r√©√©crire les requ√™tes pour les fichiers et dossiers existants dans /Public
    # Utile pour les assets (CSS, JS, images) qui doivent √™tre servis directement
    RewriteCond %{REQUEST_FILENAME} -f [OR]
    RewriteCond %{REQUEST_FILENAME} -d
    RewriteRule ^ - [L]

    # Emp√™cher l'acc√®s direct aux fichiers commen√ßant par un point (ex: .env, .git)
    # sauf pour le r√©pertoire .well-known (utilis√© par Let's Encrypt par exemple)
    RewriteRule /^\.(?!well-known\/) - [F]

    # Rediriger toutes les autres requ√™tes vers le front controller index.php
    RewriteRule ^ index.php [L]
</IfModule>

<IfModule mod_headers.c>
    # En-t√™tes de s√©curit√©
    Header set X-Content-Type-Options "nosniff"
    Header set X-Frame-Options "SAMEORIGIN"
    # X-XSS-Protection est d√©pr√©ci√©, pr√©f√©rez Content-Security-Policy
    # Header set X-XSS-Protection "1; mode=block"
    
    # Exemple de Content-Security-Policy (√Ä ADAPTER PR√âCIS√âMENT √Ä VOS BESOINS ET ASSETS)
    # Header set Content-Security-Policy "default-src 'self'; img-src 'self' data: https://placehold.co; script-src 'self' https://cdn.tailwindcss.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;"

    # Optionnel: Pour forcer HTTPS en production (si votre reverse proxy ne le fait pas d√©j√†)
    # RewriteCond %{HTTPS} !=on
    # RewriteCond %{ENV:HTTPS} !=on # Pour certains h√©bergeurs
    # RewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
</IfModule>

# Protection de fichiers sensibles (si pr√©sents √† la racine ou ailleurs accessible)
<FilesMatch "(\.(env|config|log|bak|sql|swp|yml|yaml)|composer\.(json|lock)|Dockerfile|README\.md|CONTRIBUTING\.md|LICENSE|php\.ini|Makefile|Vagrantfile|Gemfile(|\.lock))$">
    Require all denied
</FilesMatch>

# Refuser l'acc√®s direct aux dossiers de l'application en dehors de Public/
# (Cette r√®gle est plus pour une configuration Apache globale, ici on est d√©j√† dans Public/)
# Mais si des liens symboliques ou des alias existent, cela peut √™tre une s√©curit√© suppl√©mentaire.
# RewriteRule ^(src|vendor|config|routes)/ - [F,L]

/***********************************************************************************
 * Fichier: Public\index.php
 ***********************************************************************************/

<?php
// Public/index.php - Contr√¥leur Frontal de GestionMySoutenance

declare(strict_types=1);

// ==============================================================================
// 1. BOOTSTRAPPING : Initialisation de l'Application
// ==============================================================================

// D√©finir le chemin racine du projet pour des chemins de fichiers fiables
define('ROOT_PATH', dirname(__DIR__));

// Charger l'autoloader de Composer. C'est une d√©pendance critique.
// Si absent, on affiche une erreur claire et on arr√™te tout.
if (!file_exists(ROOT_PATH . '/vendor/autoload.php')) {
    http_response_code(503); // Service Unavailable
    echo "<h1>Erreur Critique d'Initialisation</h1><p>D√©pendances introuvables. Veuillez ex√©cuter 'composer install' √† la racine du projet.</p>";
    exit;
}
require_once ROOT_PATH . '/vendor/autoload.php';

// ==============================================================================
// 2. GESTION DE L'ENVIRONNEMENT ET DES ERREURS
// ==============================================================================

try {
    // D√©tecter l'environnement (dev, prod) via une variable d'environnement serveur.
    // Par d√©faut, on consid√®re √™tre en d√©veloppement pour plus de verbosit√© en cas d'erreur.
    $appEnv = $_ENV['APP_ENV'] ?? 'development';

    if (file_exists(ROOT_PATH . '/.env')) {
        $dotenv = Dotenv\Dotenv::createImmutable(ROOT_PATH);
        $dotenv->load();
    }

} catch (\Throwable $e) {
    http_response_code(503);
    echo "<h1>Erreur Critique de Configuration</h1><p>Impossible de charger les variables d'environnement. Assurez-vous que le fichier .env existe et est correct.</p>";
    // Afficher le message d'erreur r√©el pour le d√©bogage
    echo "<p><small>D√©tail de l'erreur : " . htmlspecialchars($e->getMessage()) . "</small></p>";
    error_log("Erreur Dotenv: " . $e->getMessage());
    exit;
}


// Configurer l'affichage des erreurs en fonction de l'environnement.
// En d√©veloppement : tout afficher pour d√©boguer facilement.
// En production : ne rien afficher √† l'utilisateur et tout logger.
if ($appEnv === 'development') {
    ini_set('display_errors', '1');
    ini_set('display_startup_errors', '1');
    error_reporting(E_ALL);
} else {
    ini_set('display_errors', '0');
    ini_set('display_startup_errors', '0');
    error_reporting(0);
    // La journalisation des erreurs est g√©r√©e par le ServiceLogger qui sera configur√© plus tard.
}

// ==============================================================================
// 3. D√âMARRAGE DU CONTENEUR DE SERVICES ET DE LA SESSION
// ==============================================================================

use App\Config\Container;
use App\Backend\Util\DatabaseSessionHandler;

// Instancier le conteneur d'injection de d√©pendances. C'est le chef d'orchestre.
$container = new Container();

// Configurer PHP pour utiliser notre gestionnaire de session bas√© sur la base de donn√©es.
// Cela centralise les sessions et permet des fonctionnalit√©s avanc√©es.
$sessionHandler = $container->get(DatabaseSessionHandler::class);
session_set_save_handler($sessionHandler, true);

// Configurer les param√®tres de cookie de session pour plus de s√©curit√©.
session_set_cookie_params([
    'lifetime' => (int)($_ENV['SESSION_LIFETIME'] ?? 3600), // Dur√©e de vie du cookie
    'path' => '/',
    'domain' => $_ENV['SESSION_DOMAIN'] ?? $_SERVER['SERVER_NAME'],
    'secure' => ($_ENV['APP_ENV'] === 'production'), // 'true' en production (HTTPS)
    'httponly' => true, // Emp√™che l'acc√®s au cookie via JavaScript
    'samesite' => 'Lax' // Protection contre les attaques CSRF
]);

// D√©marrer la session.
session_start();

// ==============================================================================
// 4. ROUTAGE : Interpr√©tation de la Requ√™te HTTP
// ==============================================================================

// Utilisation de FastRoute, une biblioth√®que de routage l√©g√®re et performante.
// On d√©finit toutes les routes de l'application en une seule fois.
$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) {
    $routesFilePath = ROOT_PATH . '/routes/web.php';
    if (!file_exists($routesFilePath)) {
        throw new \RuntimeException("Fichier de routes introuvable : " . $routesFilePath);
    }
    // Le fichier web.php retourne une fonction qui prend le collecteur de routes en argument.
    $routeDefinitionCallback = require $routesFilePath;
    $routeDefinitionCallback($r);
});

// R√©cup√©rer la m√©thode HTTP (GET, POST, etc.) et l'URI de la requ√™te.
$httpMethod = $_SERVER['REQUEST_METHOD'];
$uri = $_SERVER['REQUEST_URI'];

// Nettoyer l'URI pour enlever les param√®tres GET (ex: ?page=2).
if (false !== $pos = strpos($uri, '?')) {
    $uri = substr($uri, 0, $pos);
}
$uri = rawurldecode(rtrim($uri, '/')) ?: '/'; // D√©coder l'URI et s'assurer qu'elle commence par un /

// Lancer le dispatching : FastRoute compare la requ√™te √† la liste des routes d√©finies.
$routeInfo = $dispatcher->dispatch($httpMethod, $uri);

// ==============================================================================
// 5. DISPATCHING : Ex√©cution du Contr√¥leur Appropri√©
// ==============================================================================

try {
    switch ($routeInfo[0]) {
        // Cas 1 : La route n'a pas √©t√© trouv√©e.
        case FastRoute\Dispatcher::NOT_FOUND:
            http_response_code(404);
            // On inclut une vue d'erreur propre.
            include ROOT_PATH . '/src/Frontend/views/errors/404.php';
            break;

        // Cas 2 : La route existe, mais pas pour cette m√©thode HTTP (ex: POST sur une route GET).
        case FastRoute\Dispatcher::METHOD_NOT_ALLOWED:
            $allowedMethods = $routeInfo[1];
            http_response_code(405);
            header('Allow: ' . implode(', ', $allowedMethods)); // Indiquer les m√©thodes autoris√©es
            include ROOT_PATH . '/src/Frontend/views/errors/405.php';
            break;

        // Cas 3 : La route a √©t√© trouv√©e !
        case FastRoute\Dispatcher::FOUND:
            $handler = $routeInfo[1]; // Le gestionnaire (ex: [UtilisateurController::class, 'index'])
            $vars = $routeInfo[2];    // Les variables de l'URI (ex: l'ID dans /users/{id})

            // V√©rifier que le gestionnaire est bien un tableau [classe, m√©thode].
            if (is_array($handler) && count($handler) === 2 && class_exists($handler[0])) {
                $controllerClass = $handler[0];
                $methodName = $handler[1];

                // Utiliser notre conteneur pour obtenir une instance du contr√¥leur.
                // Le conteneur s'occupera d'injecter toutes ses d√©pendances (services, etc.).
                $controllerInstance = $container->get($controllerClass);

                if (!method_exists($controllerInstance, $methodName)) {
                    throw new \RuntimeException("La m√©thode '{$methodName}' n'existe pas sur le contr√¥leur '{$controllerClass}'.");
                }

                // Appeler la m√©thode du contr√¥leur en lui passant les variables de l'URI.
                call_user_func_array([$controllerInstance, $methodName], $vars);
            } else {
                throw new \RuntimeException("Gestionnaire de route mal configur√© pour l'URI : " . htmlspecialchars($uri));
            }
            break;
    }
} catch (\Throwable $e) {
    // Capture de toutes les erreurs non intercept√©es pour un affichage propre.
    http_response_code(500);
    // Logger l'erreur compl√®te pour le d√©bogage.
    error_log("Erreur non intercept√©e dans index.php: " . $e->getMessage() . " dans " . $e->getFile() . ":" . $e->getLine() . "\n" . $e->getTraceAsString());

    // Afficher une page d'erreur g√©n√©rique en production, ou les d√©tails en d√©veloppement.
    if ($appEnv === 'development') {
        echo "<h1>Erreur 500 - Erreur Interne du Serveur</h1><p>D√©tails: " . htmlspecialchars($e->getMessage()) . "</p>";
        echo "<pre>" . htmlspecialchars($e->getTraceAsString()) . "</pre>";
    } else {
        include ROOT_PATH . '/src/Frontend/views/errors/500.php';
    }
}

/***********************************************************************************
 * Fichier: Public\test-email.php
 ***********************************************************************************/

<?php
require_once '../vendor/autoload.php';

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\SMTP;

$mail = new PHPMailer(true);

try {
    // Configuration serveur
    $mail->isSMTP();
    $mail->Host       = 'mailhog';  // Dans Docker, utiliser le nom du service
    $mail->SMTPAuth   = false;      // Pas d'authentification avec MailHog
    $mail->Port       = 1025;       // Port SMTP de MailHog

    // Destinataires
    $mail->setFrom('no-reply@gestionsoutenance.dev', 'GestionMySoutenance Test');
    $mail->addAddress('etudiant@test.com', '√âtudiant Test');

    // Contenu
    $mail->isHTML(true);
    $mail->Subject = 'üß™ Test Email - ' . date('Y-m-d H:i:s');
    $mail->Body    = '
    <h1>Test Email depuis GestionMySoutenance</h1>
    <p>Ceci est un email de test envoy√© le <strong>' . date('Y-m-d H:i:s') . '</strong></p>
    <p>Si vous recevez cet email dans MailHog, la configuration fonctionne parfaitement ! üéâ</p>
    <hr>
    <p><small>Envoy√© depuis : ManuelD-Aho</small></p>
    ';

    $mail->send();
    echo '‚úÖ Email envoy√© avec succ√®s !<br>';
    echo 'üì¨ V√©rifiez MailHog : <a href="http://localhost:8025" target="_blank">http://localhost:8025</a>';
} catch (Exception $e) {
    echo "‚ùå Erreur d'envoi : {$mail->ErrorInfo}";
}
?>
